<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Vim documentation: vital/ConcurrentProcess</title>
<meta name="Generator" content="Vim/8.2">
<meta name="plugin-version" content="vim8.1_v2">
<meta name="syntax" content="help">
<meta name="settings" content="no_progress,ignore_folding,use_css,no_foldcolumn,expand_tabs,ignore_conceal,prevent_copy=,use_input_for_pc=fallback">
<meta name="colorscheme" content="github">
<style>
<!--
.MissingTag { background-color: black; color: white; }
.EnglishTag { background-color: gray; color: white; }
pre { font-family: monospace; color: #24292e; background-color: #ffffff; }
body { font-family: monospace; color: #24292e; background-color: #ffffff; }
* { font-size: 1em; }
.PreProc { color: #d73a49; }
.Todo { color: #6f42c1; text-decoration: underline; }
.helpExample { font-weight: bold; }
.String { color: #032f62; }
.Special { color: #6f42c1; }
.Ignore { color: #babbbc; background-color: #ffffff; padding-bottom: 1px; }
.Statement { color: #d73a49; }
-->
</style>
</head>
<body>

<a name="top"></a><h1>Vim documentation: vital/ConcurrentProcess</h1>
<a href="./../index.html">main help file</a>
<hr>
<pre id='vimCodeElement'>
<a class="String" href="./../vital/ConcurrentProcess.html" name="vital/ConcurrentProcess.txt">vital/ConcurrentProcess.txt</a>   Manages processes concurrently with vimproc.

Maintainer: ujihisa &lt;ujihisa at gmail com&gt;

<span class="PreProc">==============================================================================</span>
<span class="Statement">CONTENTS</span>                        <a class="String" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess-contents" name="Vital.ConcurrentProcess-contents">Vital.ConcurrentProcess-contents</a>

INTRODUCTION                    <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess-introduction">Vital.ConcurrentProcess-introduction</a>
  USAGE                         <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess-usage">Vital.ConcurrentProcess-usage</a>
  PRINCIPLE                     <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess-principle">Vital.ConcurrentProcess-principle</a>
INTERFACE                       <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess-interface">Vital.ConcurrentProcess-interface</a>
  FUNCTIONS                       <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess-functions">Vital.ConcurrentProcess-functions</a>
TERMS                           <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess-terms">Vital.ConcurrentProcess-terms</a>



<span class="PreProc">==============================================================================</span>
<span class="Statement">INTRODUCTION</span>                    <a class="String" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess-introduction" name="Vital.ConcurrentProcess-introduction">Vital.ConcurrentProcess-introduction</a>

<a class="String" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess" name="Vital.ConcurrentProcess">Vital.ConcurrentProcess</a> (or if it's too long you can all it as concproc) is
to communicate with external process concurrently with using <a href="https://www.google.com/search?q=vim+%22vimproc%22&lr=lang_en"><span class="MissingTag">vimproc</span></a>.  This
library stores external processes information spawned by this library, and
provides higher layer concurrent synchronous non-blocking read/write
interface. This library doesn't use thread nor fork, so by nature this library
can't crash Vim by them.

This module is most likely used for following types of Vim plugins:
* Language support (code completion, execution, or inspection) with using the
  language runtime process.
  (e.g. neoclojure.vim provides clojure code completion and execution with
  using leiningen as a persistent external process)
  <span class="String"><a href="https://github.com/ujihisa/neoclojure.vim">https://github.com/ujihisa/neoclojure.vim</a></span>
* Networking with using external process.
  (e.g. create a zeromq connection via external ruby process, and use it from
  Vim concurrently)

ConcurrentProcess is particularly powerful if the external process takes long
time to start, comparing to do without using ConcurrentProcess, because it's
managed by ConcurrentProcess.
(e.g. JVM, or any scripting languages with lots of libraries)

<span class="Todo">Note</span> that this library doesn't work on Vim without vimproc; vimproc is
required.


<span class="PreProc">==============================================================================</span>
<span class="Statement">USAGE</span>                           <a class="String" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess-usage" name="Vital.ConcurrentProcess-usage">Vital.ConcurrentProcess-usage</a>

Here I will introduce 3 different usage depending on your purpose.

1. like system(cmd) -- run external command and wait until the end.

This is the simplest example; the following sample code runs &quot;ls&quot; command as
an external process, wait for the termination of the process synchronously,
and returns the output. This also takes care of exceptional cases such as (1)
taking longer time than you have expected, (2) unexpected stderr output, or (3)
failure of invoking the external command itself (as an exception thornw.)

<span class="Todo">Note</span> that this usage gives you little benefit to you comparing just to use
system(), vimproc#system(), or Vital.Process.system(). Keep reading other
examples before you try to use this for your own plugin ;)

<span class="helpExample">        let s:CP = vital#{plugin-name}#new().import('ConcurrentProcess')</span>

<span class="helpExample">        function! s:list_files(path) abort</span>
<span class="helpExample">          let label = s:CP.of(['ls', a:path], '', [</span>
<span class="helpExample">                \ ['*read-all*', 'x']])</span>
<span class="helpExample">          let [out, err, timeout_p] = s:CP.consume_all_blocking(label, 'x', 1.0)</span>

<span class="helpExample">          if timeout_p</span>
<span class="helpExample">            throw 'Timed out'</span>
<span class="helpExample">          elseif err !=# ''</span>
<span class="helpExample">            throw printf(&quot;[STDERR] %s&quot;, err)</span>
<span class="helpExample">          endif</span>
<span class="helpExample">          return split(out, '\r\?\n')</span>
<span class="helpExample">        endfunction</span>

<span class="helpExample">        echo s:list_files('/') &quot; == ['bin', 'boot', 'dev', 'etc', ...]</span>


Things to learn from this example:
* <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.of()">Vital.ConcurrentProcess.of()</a> with '*read-all*' query
<span class="Statement">   </span> * This creates an external process, and reserve ConcurrentProcess to read
      all the stdout/stderr until the process terminates by itself.
* <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.consume_all_blocking()">Vital.ConcurrentProcess.consume_all_blocking()</a>
<span class="Statement">   </span> * This starts the reserved queries above, in this case this start reading
      stdout/stderr, and return them once process terminates.
* The ls process will be created in the beginning of list_files(), and will be
  terminated during the function.

2. like <span class="Comment">system(cmd, input)</span>

You can give text to stdin as well.

<span class="helpExample">        let s:CP = vital#{plugin-name}#new().import('ConcurrentProcess')</span>

<span class="helpExample">        function! s:with_linenum(text) abort</span>
<span class="helpExample">          let label = s:CP.of('cat -n', '', [</span>
<span class="helpExample">                \ ['*writeln*', a:text],</span>
<span class="helpExample">                \ ['*read-all*', 'x']])</span>
<span class="helpExample">          let [out, err, timeout_p] = s:CP.consume_all_blocking(label, 'x', 1.0)</span>

<span class="helpExample">          if timeout_p</span>
<span class="helpExample">            throw 'Timed out'</span>
<span class="helpExample">          elseif err !=# ''</span>
<span class="helpExample">            throw printf(&quot;[STDERR] %s&quot;, err)</span>
<span class="helpExample">          endif</span>
<span class="helpExample">          return out</span>
<span class="helpExample">        endfunction</span>

<span class="helpExample">        echo s:with_linenum(&quot;Hello\nWorld&quot;)</span>


<span class="Todo">Note</span> that you can separate of() with different queue() call, like this. They
are different, but in this example they behave exactly samely.

<span class="helpExample">          &quot; Before</span>
<span class="helpExample">          let label = s:CP.of('cat -n', '', [</span>
<span class="helpExample">                \ ['*writeln*', a:text],</span>
<span class="helpExample">                \ ['*read-all*', 'x']])</span>

<span class="helpExample">          &quot; After</span>
<span class="helpExample">          let label = s:CP.of('cat -n', '', [])</span>
<span class="helpExample">          call s:CP.queue(label, [</span>
<span class="helpExample">                \ ['*writeln*', a:text],</span>
<span class="helpExample">                \ ['*read-all*', 'x']])</span>


3. like <span class="Comment">system(cmd, input)</span>, but reuse the process


<span class="helpExample">        function! s:calc_ruby_sync(expr) abort</span>
<span class="helpExample">          &quot; This spawns `irb` process only if</span>
<span class="helpExample">          &quot; it does not exist.</span>
<span class="helpExample">          let label = s:CP.of('irb', '', [])</span>
<span class="helpExample">          &quot; Let the irb calculate the given `expr`</span>
<span class="helpExample">          call s:CP.queue(label, [</span>
<span class="helpExample">                \ ['*writeln*', a:expr],</span>
<span class="helpExample">                \ ['*read*', '&gt; ']])</span>
<span class="helpExample">          let [out, err] = s:CP.consume(label, 'x')</span>
<span class="helpExample">          return out &quot; Usually you also handle stderr based on `err`</span>
<span class="helpExample">        endfunction</span>


<span class="PreProc">==============================================================================</span>
<span class="Statement">PRINCIPLE</span>                       <a class="String" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess-principle" name="Vital.ConcurrentProcess-principle">Vital.ConcurrentProcess-principle</a>

* Nonblocking by default
<span class="Statement"> </span> * blocking APIs should have verbose name to discourage developers to use
* Timeout is required if it's blocking
<span class="Statement"> </span> * Remember that: not to specify timeout is same to specify timeout as
    forever. Having 30 year timeout explicitly is better than to specify
    forever implicitly.
* Synchronous (asynchronous in Vim always makes trouble)
* Don't show lower layer too much easily, but don't hide completely. No
  perfect abstraction exists in the world.
* Avoid tricky specification. Function name and behaviour itself should
  explain what it does.

<span class="PreProc">==============================================================================</span>
<span class="Statement">INTERFACE</span>                       <a class="String" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess-interface" name="Vital.ConcurrentProcess-interface">Vital.ConcurrentProcess-interface</a>

The following function is to start a process, or to refer existing process.
        <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.of()">Vital.ConcurrentProcess.of()</a>
The following function is to terminate a process.
        <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.shutdown()">Vital.ConcurrentProcess.shutdown()</a>
The following function is to add queries in queue.
        <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.queue()">Vital.ConcurrentProcess.queue()</a>
The following function is to obtain information without side effect, based on
queries in the queue and etc.
        <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.is_done()">Vital.ConcurrentProcess.is_done()</a>
The following functions are to obtain information with side effect, based on
queries in the queue and etc.
        <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.consume()">Vital.ConcurrentProcess.consume()</a>
        <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.consume_all_blocking()">Vital.ConcurrentProcess.consume_all_blocking()</a>
        <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.is_busy()">Vital.ConcurrentProcess.is_busy()</a>
The following functions are for debugging.
        <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.log_clear()">Vital.ConcurrentProcess.log_clear()</a>
        <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.log_dump()">Vital.ConcurrentProcess.log_dump()</a>
Etc
        <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.tick()">Vital.ConcurrentProcess.tick()</a>
        <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.is_available()">Vital.ConcurrentProcess.is_available()</a>

<span class="PreProc">------------------------------------------------------------------------------</span>
<span class="Statement">FUNCTIONS</span>                       <a class="String" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess-functions" name="Vital.ConcurrentProcess-functions">Vital.ConcurrentProcess-functions</a>

of(<span class="Special">{command}</span>, <span class="Special">{dir}</span>, <span class="Special">{list}</span>)                    <a class="String" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.of()" name="Vital.ConcurrentProcess.of()">Vital.ConcurrentProcess.of()</a>
        Spawns an external process based on the arguments, and returns a
        string which is used as <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess-term.label">Vital.ConcurrentProcess-term.label</a> later.

        Besides the side-effect, the return value is idempotent; if you give
        exactly same arguments, this function always returns exactly same
        string.

        Check <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess-usage">Vital.ConcurrentProcess-usage</a> how to use this with other
        functions.

        <span class="Special">{command}</span> can be a single string that contains both command name and
        command line options such as &quot;ls /tmp&quot;, or it can also be a list such
        as [&quot;ls&quot;, &quot;/tmp&quot;]

        Idempotent? Yes -- but side-effect can be different.

is_available()                  <a class="String" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.is_available()" name="Vital.ConcurrentProcess.is_available()">Vital.ConcurrentProcess.is_available()</a>
        Returns 1 if the running Vim can use ConcurrentProcess, otherwise 0.

        Idempotent? Yes

tick(<span class="Special">{label}</span>)                           <a class="String" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.tick()" name="Vital.ConcurrentProcess.tick()">Vital.ConcurrentProcess.tick()</a>
        This is an action <a href="https://www.google.com/search?q=vim+%22Vital.ConcurrentProcess-term.action%22&lr=lang_en"><span class="MissingTag">Vital.ConcurrentProcess-term.action</span></a>, and does
        nothing besides action.

queue(<span class="Special">{label}</span>, <span class="Special">{list}</span>)                  <a class="String" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.queue()" name="Vital.ConcurrentProcess.queue()">Vital.ConcurrentProcess.queue()</a>
        Pushes the given <span class="Special">{list}</span> of queries into the queue for the process.
        The query has to be either one of them.
        ['*writeln*', string]
        ['*read*', string, string]
        ['*read-all*', string]


<span class="helpExample">        call s:CP.queue(label, [</span>
<span class="helpExample">              \ ['*writeln*', '1 + 2'],</span>
<span class="helpExample">              \ ['*read*', 'x', '&gt; ']])</span>
<span class="helpExample">        let [out, err] = s:CP.consume(label, 'x')</span>
<span class="helpExample">        &quot; out may contain &quot;3&quot;</span>


        <span class="Todo">Notes</span>:
        * '*write*' without newline does not exist yet. Please ask me if you
          actually need it.
        * '*read-all*' must be always at the very end.
        * '*read-all*' automatically closes stdin pipe beforehand.

consume(<span class="Special">{label}</span>, <span class="Special">{varname}</span>)             <a class="String" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.consume()" name="Vital.ConcurrentProcess.consume()">Vital.ConcurrentProcess.consume()</a>
        This is an action <a href="https://www.google.com/search?q=vim+%22Vital.ConcurrentProcess-term.action%22&lr=lang_en"><span class="MissingTag">Vital.ConcurrentProcess-term.action</span></a>, and returns
        accumulated value for <span class="Special">{varname}</span> immediately, and remove it from
        internal buffer.

        similar to consume() described above, but this doesn't immediately
        return the current output but blocks until the end of the read of the
        given <span class="Special">{varname}</span>, at most <span class="Special">{timeout-sec}</span> seconds. This also returns a
        0/1 value as the 3rd element of the list to tell if it has timed out
        or not.

        Idempotent? No -- this removes the internal buffer.

consume_all_blocking(<span class="Special">{label}</span>, <span class="Special">{varname}</span>, <span class="Special">{timeout-sec}</span>)
                        <a class="String" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.consume_all_blocking()" name="Vital.ConcurrentProcess.consume_all_blocking()">Vital.ConcurrentProcess.consume_all_blocking()</a>
        This is an action <a href="https://www.google.com/search?q=vim+%22Vital.ConcurrentProcess-term.action%22&lr=lang_en"><span class="MissingTag">Vital.ConcurrentProcess-term.action</span></a>, and does
        similar to consume() described above, but this doesn't immediately
        return the current output but blocks until the end of the read of the
        given <span class="Special">{varname}</span>, at most <span class="Special">{timeout-sec}</span> seconds. This also returns a
        0/1 value as the 3rd element of the list to tell if it has timed out
        or not.

<span class="helpExample">        &quot; get stdout/stderr for the var x, with blocking at worst 10 seconds.</span>
<span class="helpExample">        let [out, err, timeout_p] =</span>
<span class="helpExample">              \ s:CP.consume_all_blocking(label, 'x', 10)</span>
<span class="helpExample">        if timeout_p</span>
<span class="helpExample">          &quot; omg it timed out!</span>
<span class="helpExample">        else</span>
<span class="helpExample">          &quot; yes it completed without 10 seconds. Do normal stuff here</span>
<span class="helpExample">        endif</span>

        For your info this function is internally using is_done() described
        below.

        Idempotent? No -- this removes the internal buffer.

is_done(<span class="Special">{label}</span>, <span class="Special">{varname}</span>)             <a class="String" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.is_done()" name="Vital.ConcurrentProcess.is_done()">Vital.ConcurrentProcess.is_done()</a>
        This is an action <a href="https://www.google.com/search?q=vim+%22Vital.ConcurrentProcess-term.action%22&lr=lang_en"><span class="MissingTag">Vital.ConcurrentProcess-term.action</span></a>, and checks
        if the read operation of given <span class="Special">{varname}</span> has completed. You are
        particularly expected to use this function when you use consume().

        e.g.
        is_done(label, 'x') == 1 if you didn't read/read-all with 'x' yet
        is_done(label, 'x') == 1 if you did read/read-all with 'x' and it
        completed.
        is_done(label, 'x') == 1 if you did read/read-all with 'x' and it
        didn't complete, but the process crashed and after auto restart you
        didn't read/read-all yet.
        is_done(label, 'x') == 0 only if you did read/read-all with 'x' and it
        didn't complete nor crash yet.

        Idempotent? No -- return value depends on internal state.

is_busy(<span class="Special">{label}</span>)                        <a class="String" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.is_busy()" name="Vital.ConcurrentProcess.is_busy()">Vital.ConcurrentProcess.is_busy()</a>
        This is an action <a href="https://www.google.com/search?q=vim+%22Vital.ConcurrentProcess-term.action%22&lr=lang_en"><span class="MissingTag">Vital.ConcurrentProcess-term.action</span></a>, and checks
        if the queries are currently empty.

        This function is possibly used for checking if you can query
        something light and get the response immedicately, with using
        consume_all_blocking(), like for code completion.


<span class="helpExample">        if s:CP.is_busy(label, 'code-completion')</span>
<span class="helpExample">          return 'Busy for something else. Try later please.'</span>
<span class="helpExample">        else</span>
<span class="helpExample">          call s:CP.queue([</span>
<span class="helpExample">                \ ['*writeln*', something],</span>
<span class="helpExample">                \ ['*read*', 'code-completion', another_something]])</span>
<span class="helpExample">          return s:CP.consume_all_blocking(label, 'code-completion', 0.5)</span>
<span class="helpExample">        endif</span>


        Idempotent? No -- return value depends on internal state.

shutdown(<span class="Special">{label}</span>)                       <a class="String" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.shutdown()" name="Vital.ConcurrentProcess.shutdown()">Vital.ConcurrentProcess.shutdown()</a>
        Terminates the underlying process for the given label immediately, no
        matter how many queries are in the queue. This also removes all
        internal buffers for the process, including queries and logs.

log_clear(<span class="Special">{label}</span>)                      <a class="String" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.log_clear()" name="Vital.ConcurrentProcess.log_clear()">Vital.ConcurrentProcess.log_clear()</a>
        Just to wipe out accumulated logs for the process.

log_dump(<span class="Special">{label}</span>)                       <a class="String" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.log_dump()" name="Vital.ConcurrentProcess.log_dump()">Vital.ConcurrentProcess.log_dump()</a>
        Print out the accumulated logs for the process, and wipe out it.

        Idempotent? No -- output depends on the internal buffer and every time
        you call this ConcurrentProcess removes buffer.

<span class="PreProc">------------------------------------------------------------------------------</span>
<span class="Statement">TERMS</span>                           <a class="String" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess-terms" name="Vital.ConcurrentProcess-terms">Vital.ConcurrentProcess-terms</a>

label                                   <a class="String" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess-term.label" name="Vital.ConcurrentProcess-term.label">Vital.ConcurrentProcess-term.label</a>
        A string that represents a running/dead process managed by
        ConcurrentProcess.

action
        The external process runs in parallel independent to Vim, but the
        communication between Vim and the process is always done
        synchronously. A function which is an action, such as consume(), will
        trigger the communication; reads from stdout/stderr, or writes to stdin
        if there's corresponding queue.

        The following functions are actions.
        * <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.tick()">Vital.ConcurrentProcess.tick()</a>
        * <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.consume()">Vital.ConcurrentProcess.consume()</a>
        * <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.consume_all_blocking()">Vital.ConcurrentProcess.consume_all_blocking()</a>
        * <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.is_done()">Vital.ConcurrentProcess.is_done()</a>
        * <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.queue()">Vital.ConcurrentProcess.queue()</a>
        * <a class="Identifier" href="./../vital/ConcurrentProcess.html#Vital.ConcurrentProcess.is_busy()">Vital.ConcurrentProcess.is_busy()</a>

<span class="PreProc">==============================================================================</span>
vim&#0058;tw=78:fo=tcq2mM:ts=8:ft=help:norl
</pre>
<hr>
<a href="#top">top</a> - <a href="./../index.html">main help file</a> - <a href="./../tags.html">tag index</a> <br>

</body>
</html>
<!-- vim: set foldmethod=manual : -->

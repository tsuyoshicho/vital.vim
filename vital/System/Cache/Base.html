<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Vim documentation: vital/System/Cache/Base</title>
<meta name="Generator" content="Vim/8.2">
<meta name="plugin-version" content="vim8.1_v2">
<meta name="syntax" content="help">
<meta name="settings" content="no_progress,ignore_folding,use_css,no_foldcolumn,expand_tabs,ignore_conceal,prevent_copy=,use_input_for_pc=fallback">
<meta name="colorscheme" content="github">
<style>
<!--
.MissingTag { background-color: black; color: white; }
.EnglishTag { background-color: gray; color: white; }
pre { font-family: monospace; color: #24292e; background-color: #ffffff; }
body { font-family: monospace; color: #24292e; background-color: #ffffff; }
* { font-size: 1em; }
.PreProc { color: #d73a49; }
.helpExample { font-weight: bold; }
.Special { color: #6f42c1; }
.Ignore { color: #babbbc; background-color: #ffffff; padding-bottom: 1px; }
.Statement { color: #d73a49; }
-->
</style>
</head>
<body>

<a name="top"></a><h1>Vim documentation: vital/System/Cache/Base</h1>
<a href="./../../../index.html">main help file</a>
<hr>
<pre id='vimCodeElement'>
<a class="String" href="./../../../vital/System/Cache/Base.html" name="vital/System/Cache/Base.txt">vital/System/Cache/Base.txt</a>   An abstract class of unified cache system

Maintainer: Alisue &lt;lambdalisue@hashnote.net&gt;


<span class="PreProc">==============================================================================</span>
<span class="Statement">CONTENTS</span>                        <a class="String" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-contents" name="Vital.System.Cache.Base-contents">Vital.System.Cache.Base-contents</a>

Introductions           <a class="Identifier" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-intro">Vital.System.Cache.Base-intro</a>
Tutorial                <a class="Identifier" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-tutorial">Vital.System.Cache.Base-tutorial</a>
Interface               <a class="Identifier" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-interface">Vital.System.Cache.Base-interface</a>
  Functions             <a class="Identifier" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-functions">Vital.System.Cache.Base-functions</a>
  Methods               <a class="Identifier" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-methods">Vital.System.Cache.Base-methods</a>


<span class="PreProc">==============================================================================</span>
<span class="Statement">INTRODUCTIONS</span>                           <a class="String" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-intro" name="Vital.System.Cache.Base-intro">Vital.System.Cache.Base-intro</a>

<a class="String" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base" name="Vital.System.Cache.Base">Vital.System.Cache.Base</a> is an abstract class of unified cache system.
The following variants are currently available.

- <a class="Identifier" href="./../../../vital/System/Cache/Dummy.html#Vital.System.Cache.Dummy">Vital.System.Cache.Dummy</a>      : A dummy cache system
- <a class="Identifier" href="./../../../vital/System/Cache/Memory.html#Vital.System.Cache.Memory">Vital.System.Cache.Memory</a>     : A dictionary instance based cache system
- <a class="Identifier" href="./../../../vital/System/Cache/File.html#Vital.System.Cache.File">Vital.System.Cache.File</a>       : A file based cache system
- <a class="Identifier" href="./../../../vital/System/Cache/SingleFile.html#Vital.System.Cache.SingleFile">Vital.System.Cache.SingleFile</a> : A single file based cache system

This document is for creating your own variants. See <a class="Identifier" href="./../../../vital/System/Cache.html#Vital.System.Cache">Vital.System.Cache</a> for
the cache system usage.


<span class="PreProc">==============================================================================</span>
Tutorial                                <a class="String" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-tutorial" name="Vital.System.Cache.Base-tutorial">Vital.System.Cache.Base-tutorial</a>

First of all, create s:new(...) function to return an instance of your variant
like:

<span class="helpExample">        function! s:_vital_loaded(V) abort &quot; {{{</span>
<span class="helpExample">          let s:Base = a:V.import('System.Cache.Base')</span>
<span class="helpExample">        endfunction &quot; }}}</span>
<span class="helpExample">        function! s:_vital_depends() abort &quot; {{{</span>
<span class="helpExample">          return ['System.Cache.Base']</span>
<span class="helpExample">        endfunction &quot; }}}</span>

<span class="helpExample">        let s:cache = {</span>
<span class="helpExample">              \ '_cached': {},</span>
<span class="helpExample">              \ '__name__': 'your_variant_name',</span>
<span class="helpExample">              \}</span>
<span class="helpExample">        function! s:new(...)</span>
<span class="helpExample">          return extend(</span>
<span class="helpExample">                \ call(s:Base.new, a:000, s:Base),</span>
<span class="helpExample">                \ deepcopy(s:cache)</span>
<span class="helpExample">                \)</span>
<span class="helpExample">        endfunction</span>

Then add &quot;has&quot;, &quot;get&quot;, &quot;set&quot;, &quot;keys&quot;, &quot;remove&quot;, and &quot;clear&quot; methods into your
cache instance like:

<span class="helpExample">        function! s:cache.has(name) abort</span>
<span class="helpExample">          let cache_key = self.cache_key(a:name)</span>
<span class="helpExample">          return has_key(self._cached, cache_key)</span>
<span class="helpExample">        endfunction</span>

<span class="helpExample">        function! s:cache.get(name, ...) abort</span>
<span class="helpExample">          let default = get(a:000, 0, '')</span>
<span class="helpExample">          let cache_key = self.cache_key(a:name)</span>
<span class="helpExample">          if has_key(self._cached, cache_key)</span>
<span class="helpExample">            return self._cached[cache_key]</span>
<span class="helpExample">          else</span>
<span class="helpExample">            return default</span>
<span class="helpExample">          endif</span>
<span class="helpExample">        endfunction</span>

<span class="helpExample">        function! s:cache.set(name, value) abort</span>
<span class="helpExample">          let cache_key = self.cache_key(a:name)</span>
<span class="helpExample">          let self._cached[cache_key] = a:value</span>
<span class="helpExample">        endfunction</span>

<span class="helpExample">        function! s:cache.keys() abort</span>
<span class="helpExample">          return keys(self._cached)</span>
<span class="helpExample">        endfunction</span>

<span class="helpExample">        function! s:cache.remove(name) abort</span>
<span class="helpExample">          let cache_key = self.cache_key(a:name)</span>
<span class="helpExample">          if has_key(self._cached, cache_key)</span>
<span class="helpExample">            unlet self._cached[cache_key]</span>
<span class="helpExample">          endif</span>
<span class="helpExample">        endfunction</span>

<span class="helpExample">        function! s:cache.clear() abort</span>
<span class="helpExample">          let self._cached = {}</span>
<span class="helpExample">        endfunction</span>


<span class="PreProc">==============================================================================</span>
<span class="Statement">INTERFACE</span>                               <a class="String" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-interface" name="Vital.System.Cache.Base-interface">Vital.System.Cache.Base-interface</a>

To provide unified interface. The following functions and method are required
to be implemented.

<span class="PreProc">-------------------------------------------------------------------------------</span>
<span class="Statement">FUNCTIONS</span>                               <a class="String" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-functions" name="Vital.System.Cache.Base-functions">Vital.System.Cache.Base-functions</a>

new([<span class="Special">{options}</span>])                        <a class="String" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base.new()" name="Vital.System.Cache.Base.new()">Vital.System.Cache.Base.new()</a>

        Create a new instance of System.Cache.Base.
        If your variant require any extra information, use a dictionary to
        specify values like:

<span class="helpExample">        let s:cache = { '__name__': 'your_variant_name' }</span>
<span class="helpExample">        function! s:new(...) abort</span>
<span class="helpExample">            let options = extend({</span>
<span class="helpExample">                \ 'foo': 'bar',</span>
<span class="helpExample">                \}, get(a:000, 0, {}))</span>
<span class="helpExample">            return extend(</span>
<span class="helpExample">                \ call(s:Base.new, a:000, s:Base),</span>
<span class="helpExample">                \ extend(options, deepcopy(s:cache))</span>
<span class="helpExample">                \)</span>
<span class="helpExample">        endfunction</span>

<span class="PreProc">-------------------------------------------------------------------------------</span>
<span class="Statement">METHODS</span>                                 <a class="String" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-methods" name="Vital.System.Cache.Base-methods">Vital.System.Cache.Base-methods</a>

cache_key(<span class="Special">{obj}</span>)        <a class="String" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-instance.cache_key()" name="Vital.System.Cache.Base-instance.cache_key()">Vital.System.Cache.Base-instance.cache_key()</a>

        Return a <a href="https://www.google.com/search?q=vim+%22String%22&lr=lang_en"><span class="MissingTag">String</span></a> which will be used as a cache key.
        Variants can override this method to create a cache key from <span class="Special">{obj}</span>.
        In default, it returns <span class="Special">{obj}</span> if the <span class="Special">{obj}</span> is <a href="https://www.google.com/search?q=vim+%22String%22&lr=lang_en"><span class="MissingTag">String</span></a>. Otherwise it
        returns a string representation (See <a href="https://www.google.com/search?q=vim+%22string()%22&lr=lang_en"><span class="MissingTag">string()</span></a> for details) of the
        <span class="Special">{obj}</span>.

has(<span class="Special">{name}</span>)             <a class="String" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-instance.has()" name="Vital.System.Cache.Base-instance.has()">Vital.System.Cache.Base-instance.has()</a>

        Whether the cache instance has a <span class="Special">{name}</span> cache or not.

        VARIANTS MUST OVERRIDE THIS METHOD

        <span class="Special">{name}</span> (required)
        A name of the cache. An actual cache key SHOULD be created via
        <a class="Identifier" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-instance.cache_key()">Vital.System.Cache.Base-instance.cache_key()</a> method thus <span class="Special">{name}</span> is not
        required to be <a href="https://www.google.com/search?q=vim+%22String%22&lr=lang_en"><span class="MissingTag">String</span></a>.

        See the following example:

<span class="helpExample">        function! s:cache.has(name) abort</span>
<span class="helpExample">            let cache_key = self.cache_key(a:name)</span>
<span class="helpExample">            return has_key(self._cached, cache_key)</span>
<span class="helpExample">        endfunction</span>

                        <a class="String" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-instance.get()" name="Vital.System.Cache.Base-instance.get()">Vital.System.Cache.Base-instance.get()</a>
get(<span class="Special">{name}</span>[, <span class="Special">{default}</span>])

        Return a <span class="Special">{name}</span> cache. If no <span class="Special">{name}</span> cache is found, it returns
        <span class="Special">{default}</span> or an empty <a href="https://www.google.com/search?q=vim+%22String%22&lr=lang_en"><span class="MissingTag">String</span></a>.

        VARIANTS MUST OVERRIDE THIS METHOD

        <span class="Special">{name}</span> (required)
        A name of the cache. An actual cache key SHOULD be created via
        <a class="Identifier" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-instance.cache_key()">Vital.System.Cache.Base-instance.cache_key()</a> method thus <span class="Special">{name}</span> is not
        required to be <a href="https://www.google.com/search?q=vim+%22String%22&lr=lang_en"><span class="MissingTag">String</span></a>.

        <span class="Special">{default}</span> (optional)
        A default value. If no <span class="Special">{default}</span> is specified, an empty <a href="https://www.google.com/search?q=vim+%22String%22&lr=lang_en"><span class="MissingTag">String</span></a>
        should be used.

        See the following example:

<span class="helpExample">        function! s:cache.get(name, ...) abort</span>
<span class="helpExample">            let default = get(a:000, 0, '')</span>
<span class="helpExample">            let cache_key = self.cache_key(a:name)</span>
<span class="helpExample">            if has_key(self._cached, cache_key)</span>
<span class="helpExample">                return self._cached[cache_key]</span>
<span class="helpExample">            endif</span>
<span class="helpExample">            return default</span>
<span class="helpExample">        endfunction</span>

set(<span class="Special">{name}</span>, <span class="Special">{value}</span>)    <a class="String" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-instance.set()" name="Vital.System.Cache.Base-instance.set()">Vital.System.Cache.Base-instance.set()</a>

        Save <span class="Special">{value}</span> as a <span class="Special">{name}</span> cache.

        VARIANTS MUST OVERRIDE THIS METHOD

        <span class="Special">{name}</span> (required)
        A name of the cache. An actual cache key SHOULD be created via
        <a class="Identifier" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-instance.cache_key()">Vital.System.Cache.Base-instance.cache_key()</a> method thus <span class="Special">{name}</span> is not
        required to be <a href="https://www.google.com/search?q=vim+%22String%22&lr=lang_en"><span class="MissingTag">String</span></a>.

        <span class="Special">{value}</span> (required)
        A value of the cache.

        See the following example:

<span class="helpExample">        function! s:cache.set(name, value) abort</span>
<span class="helpExample">          let cache_key = self.cache_key(a:name)</span>
<span class="helpExample">          let self._cached[cache_key] = a:value</span>
<span class="helpExample">        endfunction</span>

keys()                  <a class="String" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-instance.keys()" name="Vital.System.Cache.Base-instance.keys()">Vital.System.Cache.Base-instance.keys()</a>

        Return a list of cache keys

        VARIANTS MUST OVERRIDE THIS METHOD

remove(<span class="Special">{name}</span>)          <a class="String" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-instance.remove()" name="Vital.System.Cache.Base-instance.remove()">Vital.System.Cache.Base-instance.remove()</a>

        Remove a <span class="Special">{name}</span> cache. If no <span class="Special">{name}</span> cache is found, it should do
        nothing.

        VARIANTS MUST OVERRIDE THIS METHOD

        <span class="Special">{name}</span> (required)
        A name of the cache. An actual cache key will be created via
        <a class="Identifier" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-instance.cache_key()">Vital.System.Cache.Base-instance.cache_key()</a> method thus <span class="Special">{name}</span> is not
        required to be <a href="https://www.google.com/search?q=vim+%22String%22&lr=lang_en"><span class="MissingTag">String</span></a>.

        See the following example:

<span class="helpExample">        function! s:cache.remove(name) abort</span>
<span class="helpExample">          let cache_key = self.cache_key(a:name)</span>
<span class="helpExample">          if has_key(self._cached, cache_key)</span>
<span class="helpExample">            unlet self._cached[cache_key]</span>
<span class="helpExample">          endif</span>
<span class="helpExample">        endfunction</span>

clear()                 <a class="String" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-instance.clear()" name="Vital.System.Cache.Base-instance.clear()">Vital.System.Cache.Base-instance.clear()</a>

        Clear all caches

        VARIANTS MUST OVERRIDE THIS METHOD

on_changed()            <a class="String" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-instance.on_changed()" name="Vital.System.Cache.Base-instance.on_changed()">Vital.System.Cache.Base-instance.on_changed()</a>

        A user defined hook method. This method is called when the content of
        the cache is changed, namely after the following methods:
        - <a class="Identifier" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-instance.set()">Vital.System.Cache.Base-instance.set()</a>
        - <a class="Identifier" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-instance.remove()">Vital.System.Cache.Base-instance.remove()</a>
        - <a class="Identifier" href="./../../../vital/System/Cache/Base.html#Vital.System.Cache.Base-instance.clear()">Vital.System.Cache.Base-instance.clear()</a>

<span class="PreProc">==============================================================================</span>
vim&#0058;tw=78:fo=tcq2mM:ts=8:ft=help:norl
</pre>
<hr>
<a href="#top">top</a> - <a href="./../../../index.html">main help file</a> - <a href="./../../../tags.html">tag index</a> <br>

</body>
</html>
<!-- vim: set foldmethod=manual : -->
